<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>什么是Web3.0</title>
      <link href="/2022/10/31/shi-me-shi-web3-0/"/>
      <url>/2022/10/31/shi-me-shi-web3-0/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Web3-0"><a href="#什么是Web3-0" class="headerlink" title="什么是Web3.0"></a>什么是Web3.0</h1><h1 id="什么是Web-3-0-？"><a href="#什么是Web-3-0-？" class="headerlink" title="什么是Web 3.0 ？"></a>什么是Web 3.0 ？</h1><p><img src="/.io//1667183789652-9cba8aef-9ee1-4d8e-a6b4-d421eb87e6f5.jpeg"><br>Web 3.0是最近非常火的一个概念了，就算你不知道他具体是什么，但是你也一定听说过这个名词。<br>但是Web 3.0中又夹杂着很多其他的概念，比如币、DeFi、DeApps、NFT、元宇宙，等等更多其他的概念，所以很多人就更难理解了。<br>这篇文章我们站在工程师的角度来谈一谈什么是Web 3.0，为什么他广受争议，他到底发展到什么阶段了，作为普通研发者，我们能在这里面做些什么呢？<br><strong>第三代互联网</strong><br>Web 3.0很多人把它称之为第三代互联网，那么他和前两代有什么区别呢？<br>到底第三代做了啥事情呢？我们先了解下什么是 Web 1.0 和 Web 2.0。</p><h3 id="Web-1-0"><a href="#Web-1-0" class="headerlink" title="Web 1.0"></a><strong>Web 1.0</strong></h3><p>一般认为2004年之前的互联网就处于Web 1.0的时代，那时候的网站主要是提供了一些查阅信息的功能，比如像搜狐这类新闻网站、雅虎这类搜索网站，以及马云在做阿里巴巴之前搞的中国黄页。<br>这些网站的主要特点就是他们主要是做信息展示的，也就是说上面的内容你只能看。<br><strong>所以，Web 1.0是只读的。</strong></p><h3 id="Web-2-0"><a href="#Web-2-0" class="headerlink" title="Web 2.0"></a><strong>Web 2.0</strong></h3><p>那到了Web 2.0的时代之后呢，从2004年开始，很多互动式的网站、APP都接踵而至了，比如我们现在还常用的微信、抖音、FaceBook。<br><img src="/.io//1667183789631-dd785c26-0224-4212-a3dc-782fe61d5dc4.jpeg"><br>在这些Web 2.0的网站上面，你不仅能获取到很多信息，你还能参与进来做互动以及内容的产出。比如你可以做评论，发动态，发你的作品等等。<br><strong>所以，Web 2.0是能读+写的。</strong></p><h3 id="Web-3-0"><a href="#Web-3-0" class="headerlink" title="Web 3.0"></a><strong>Web 3.0</strong></h3><p>那什么是Web 3.0呢，那就是很多人认为说虽然在Web 2.0的时代，我们作为用户输出了很多内容，但是这些内容的所有权并不属于我们，而是属于那些平台的。<br>而这些平台网站，虽然他们背后的服务器部署、以及应用架构可能是做了各种分布式、异地多活、冷热备份什么的。但是，归根结底，如果这家公司倒闭了，那你的数据也都没有了。所以，他还是中心化的。<br>在Web 2.0的时代，用户生产了很多内容和数据，但是真正受益的是那些平台，他们可以利用我们的数据进行营销、广告，很多时候我们没有任何办法。<br>那于是，就有人提出了<strong>Web 3.0，在这里面，用户不仅可以读、也可以写数据，最重要是用户可以拥有自己的数据。</strong><br><img src="/.io//1667183789718-964dbbfc-1786-4678-867d-e69cea9981f9.jpeg"><br>也就是说，在Web 3.0中，我的数据不再属于任何中心化的平台、公司、或者机构，我的数据属于我自己。那么，怎么算数据属于我自己呢？<br>如果腾讯说，好的，我宣布你的朋友圈属于你自己，那就算了？那当然不是。<br>如何实现这个&lt;属于&gt;呢，这就需要用到区块链了。</p><h3 id="Web-3-0与区块链"><a href="#Web-3-0与区块链" class="headerlink" title="Web 3.0与区块链"></a><strong>Web 3.0与区块链</strong></h3><p>Web 3.0中最重要的是用户拥有自己的数据，那么也就是说我们的数据不能存储在任何中心化的存储上。这时候就需要区块链这种去中心化的技术了。<br>所以，也有人说<strong>所谓的Web 3.0，其实就是运行在区块链技术上的去中心化互联网。</strong><br><img src="/.io//1667183789660-e1d372b9-3971-4cce-b0dc-e3ef6133e671.jpeg"><br>利用区块链技术，我们每一个人都可以是链上的一个节点，而且大家都是具有平等权利和义务的，不再需要一个中心，所有的上链的动作，不再需要中心处理节点、不需要数字证书、也不需要谁批准。所有参与的节点进行共识算法投票就行了。一旦经过确权，那就不可再更改了。<br>那么，其实区块链又分为公有链、私有链还有联盟链，大家想一想就不难理解，Web 3.0应该就是构建在公有链之上的。<br><strong>Web 3.0的应用</strong><br>Web 3.0 是想建设去中心化的互联网，那么就主要需要依赖区块链的技术。那和Web 1.0和Web 2.0一样，在Web 3.0 里面肯定需要有很多网站、应用供我们使用才行，那这些应用也需要构建在区块链之上，否则也就不算Web 3.0了。<br>那么，在Web 3.0中，有自己的货币——加密货币、自己的组织形式——DAO、自己的服务模式——智能合约、自己的藏品——NFT、自己的金融——DeFi、自己的游戏——GameFi等等。。。<br><img src="/.io//1667183790180-a72ab9b6-e223-4aa3-a0dd-475a8c603072.jpeg"><br>所以，我们常说的那些数字货币、NFT、游戏、甚至是元宇宙，其实都是Web 3.0这个底层基础架构上面的实际应用。这些东西综合到一起就组成了Web 3.0。<br>当然，这些应用当中有一个比较特殊，那就是数字货币，他不仅仅是Web 3.0中的一个实际应用，更重要的是它是维持Web 3.0的一个重要基础，为什么这么说呢？<br>还记得我们前面讲过了说Web 3.0需要基于公有链来运行，那么公有链想要自主的良好运行，就需要有激励制度，要不然谁会愿意上来共同维护这个体系呢。那真的能起到激励作用的，那无非就是币了。<br><strong>Web 3.0的问题</strong><br>说了这么多，想必大家对于Web 3.0 也有一点自己的理解了。好像听上去有点意思，但是为啥还是有很多人说他不靠谱的？为啥我们听到的和这东西有关的大部分都是负面新闻呢？</p><h3 id="目的不纯"><a href="#目的不纯" class="headerlink" title="目的不纯"></a><strong>目的不纯</strong></h3><p>主要是Web 3.0目前的很多应用，无论是加密货币也好、NFT也好、智能合约也好，大多数被应用的场景还是在炒。炒着炒着就变成割了。<br>有了Web 3.0、元宇宙、数字货币等这么多高大上的概念之后，就可以开始讲故事了，只要这个故事有人信，就有人愿意参与进来。<br>话又说回来了，那你说参与进去的那些人是真的信吗？我觉得也未必，其中肯定有部分人就是抱着投机的心理进去的。想着自己可能肯定能在镰刀下来之前先走掉。<br><img src="/.io//1667183790202-825900a2-6d75-4a59-9d3a-35e031294881.jpeg"><br>很多人之所以明知道有风险还愿意进去，主要是因为这东西大大的降低了投资的门槛。在以前，你想投资一个公司，那门槛还是很高的。但是现在呢，不管公司业务好不好，先讲个故事，发个代币，就能让大家开始投资了。。。<br>其次呢，Web 3.0还有一些技术上的问题至今突破不了的。</p><h3 id="交易慢、资源浪费"><a href="#交易慢、资源浪费" class="headerlink" title="交易慢、资源浪费"></a><strong>交易慢、资源浪费</strong></h3><p>因为Web 3.0是构建在公有链之上的，而目前的公有链上的共识算法，都非常的耗费资源，而且确认的速度也很慢。<br><strong>没有中心，有问题没人管</strong><br>如果你用支付宝交易，转错账了，还有可能联系对方看看能不能要回来。如果你遇到诈骗了，可能支付宝还能提醒你不要转账。如果你的钱放到支付宝无缘无故的丢了，你还能找支付宝去要。<br>那如果没有中心了，转错钱了就转错了，对方在真实世界中到底是谁你都不知道。这就给很多诈骗、勒索的等很多机会。<br><strong>Web 3.0的开发</strong><br>那很多人就会问，这东西现在这么火，作为普通开发者，我们能参与到里面来吗？<br>现在有很多开发者都在从事Web 3.0的一些开发，但是因为这东西涉及到的概念实在太多了，所以他涉及到的技术栈也比较多，主要涉及以下这些：<br>底层技术包含了共识算法、一致性协议、密码学技术、分布式存储、人工智能、大数据等。如果涉及到虚拟现实等游戏交互的话，可能还会涉及到动作捕捉、空间感知、数字孪生等相关技术。<br>目前，为了降低开发难度，很多人会采用<strong>DApp进行开发，他的全程是Decentralized Application，指的就是建立在区块链之上的应用程序。</strong><br><img src="/.io//1667183790172-0d0d9de2-891b-4864-b5c4-834c6d950816.jpeg"><br>关于DApp，现在也有许多流行的生态系统，比如 Ethereum、Gemini 和 Solana等等，目前基于DApp实现的应用也有很多了，涉及到交易所、游戏、金融、存储、钱包、治理、身份、社交、安全、能源、保险和健康等。</p>]]></content>
      
      
      <categories>
          
          <category> web3.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8的stream</title>
      <link href="/2022/10/26/java8-de-stream/"/>
      <url>/2022/10/26/java8-de-stream/</url>
      
        <content type="html"><![CDATA[<h1 id="Stream相关系列的实战和应用"><a href="#Stream相关系列的实战和应用" class="headerlink" title="Stream相关系列的实战和应用"></a>Stream相关系列的实战和应用</h1><blockquote><p>就目前而言，Java8之类的仍然是主流，即使用比较广泛，其次就是JDK11之类的，毕竟对于企业研发而言，求稳第一。</p></blockquote><h4 id="一、Java8有哪些新特性？"><a href="#一、Java8有哪些新特性？" class="headerlink" title="一、Java8有哪些新特性？"></a>一、Java8有哪些新特性？</h4><ol><li>Lambda表达式；</li><li>新的日期API；</li><li>引入Optional；</li><li>新增Base64加解密API；</li><li>接口的默认方法和静态方法；</li><li>新增方法引用格式；</li><li>新增Stream类；</li><li>注解相关的改变；</li><li>支持并行数组；</li><li>对并发类的扩展。<br>这里不一一讲解，只讲Stream相关系列的实战和应用。</li></ol><h4 id="二、我在实践应用Stream相关的是如何提高开发效率的？"><a href="#二、我在实践应用Stream相关的是如何提高开发效率的？" class="headerlink" title="二、我在实践应用Stream相关的是如何提高开发效率的？"></a>二、我在实践应用Stream相关的是如何提高开发效率的？</h4><h5 id="以下以实用为主-实际应用比较多的-，进行分类划分。在实际中这些通常以组合的形式进行使用，不局限于单单使用某一个。这样做的目的就是为了提高研发效率以及更快更好的解决问题。不然，使用Stream这些新特性的意义也就不存在了。"><a href="#以下以实用为主-实际应用比较多的-，进行分类划分。在实际中这些通常以组合的形式进行使用，不局限于单单使用某一个。这样做的目的就是为了提高研发效率以及更快更好的解决问题。不然，使用Stream这些新特性的意义也就不存在了。" class="headerlink" title="以下以实用为主(实际应用比较多的)，进行分类划分。在实际中这些通常以组合的形式进行使用，不局限于单单使用某一个。这样做的目的就是为了提高研发效率以及更快更好的解决问题。不然，使用Stream这些新特性的意义也就不存在了。"></a>以下以实用为主(实际应用比较多的)，进行分类划分。在实际中这些通常以组合的形式进行使用，不局限于单单使用某一个。这样做的目的就是为了提高研发效率以及更快更好的解决问题。不然，使用Stream这些新特性的意义也就不存在了。</h5><h6 id="1-分组"><a href="#1-分组" class="headerlink" title="1. 分组"></a>1. 分组</h6><pre class="line-numbers language-none"><code class="language-none">Map&lt;String, List&lt;T&gt;&gt; groupMapData &#x3D; originData.stream().collect(Collectors.groupingBy(T::getType));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="2-条件筛选"><a href="#2-条件筛选" class="headerlink" title="2. 条件筛选"></a>2. 条件筛选</h6><pre class="line-numbers language-none"><code class="language-none">List&lt;T&gt; filterList &#x3D; originData.stream().filter(a -&gt; a.getName().equals(&quot;YC&quot;)).collect(Collectors.toList());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="3-排序"><a href="#3-排序" class="headerlink" title="3. 排序"></a>3. 排序</h6><pre class="line-numbers language-none"><code class="language-none">List&lt;T&gt; filterOBDHourData &#x3D; originData.stream()                       .sorted(Comparator.comparing(T::getId).reversed())                       .collect(Collectors.toList());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h6 id="4-去重"><a href="#4-去重" class="headerlink" title="4. 去重"></a>4. 去重</h6><pre class="line-numbers language-none"><code class="language-none">List&lt;T&gt; dataVOS &#x3D; originData.stream().collect(        Collectors.collectingAndThen(            Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(T::getName))), ArrayList::new)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h6 id="5-数组转List"><a href="#5-数组转List" class="headerlink" title="5. 数组转List"></a>5. 数组转List</h6><pre class="line-numbers language-none"><code class="language-none">List&lt;String&gt; codes &#x3D; new ArrayList&lt;&gt;();String[] arr &#x3D; target.trim().split(&quot;,&quot;);if (arr.length &gt; 0) &#123;  codes &#x3D; Stream.of(arr).collect(Collectors.toList());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="6-数据合并-含去重以及不去重"><a href="#6-数据合并-含去重以及不去重" class="headerlink" title="6. 数据合并(含去重以及不去重)"></a>6. 数据合并(含去重以及不去重)</h6><pre class="line-numbers language-none"><code class="language-none">List&lt;String&gt; result &#x3D; Stream.of(Lists.newArrayList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), Lists.newArrayList(&quot;A&quot;, &quot;B&quot;)).flatMap(Collection::stream).distinct().collect(Collectors.toList());List&lt;String&gt; result &#x3D; Stream.of(Lists.newArrayList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), Lists.newArrayList(&quot;A&quot;, &quot;B&quot;)).flatMap(Collection::stream).collect(Collectors.toList());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="7-分页"><a href="#7-分页" class="headerlink" title="7. 分页"></a>7. 分页</h6><pre class="line-numbers language-none"><code class="language-none">List&lt;T&gt; dataList &#x3D; originData.stream().skip((dto.getPageNum() - 1) * dto.getPageSize()).limit(dto.getPageSize()).collect(Collectors.toList());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="8-统计"><a href="#8-统计" class="headerlink" title="8. 统计"></a>8. 统计</h6><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;求最大值BigDecimal max &#x3D; dataList.stream().map(T::getPrice).max((x1, x2) -&gt; x1.compareTo(x2)).get();&#x2F;&#x2F;求最小值BigDecimal min &#x3D; dataList.stream().map(T::getPrice).min((x1, x2) -&gt; x1.compareTo(x2)).get();&#x2F;&#x2F;求和 空指针异常排除BigDecimal sum &#x3D; dataList.stream().map(vo -&gt; ObjectUtils.isEmpty(vo.getPrice()) ? new BigDecimal(0) : vo.getPrice()).reduce(BigDecimal.ZERO, BigDecimal::add);&#x2F;&#x2F;求平均值BigDecimal average &#x3D; dataList.stream().map(vo -&gt; ObjectUtils.isEmpty(vo.getPrice()) ? new BigDecimal(0) : vo.getPrice()).reduce(BigDecimal.ZERO, BigDecimal::add).divide(BigDecimal.valueOf(dataList.size()), 2, BigDecimal.ROUND_HALF_UP);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="9-拼接"><a href="#9-拼接" class="headerlink" title="9. 拼接"></a>9. 拼接</h6><pre class="line-numbers language-none"><code class="language-none">String nameJoin &#x3D; dataList.stream().map(T::getName).collect(Collectors.joining(&quot;,&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="10-归集"><a href="#10-归集" class="headerlink" title="10. 归集"></a>10. 归集</h6><pre class="line-numbers language-none"><code class="language-none">Map&lt;String, T&gt; mapNameObject &#x3D; dataList.stream().collect(Collectors.toMap(T::getName, item -&gt; item));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="11-映射Map"><a href="#11-映射Map" class="headerlink" title="11. 映射Map"></a>11. 映射Map</h6><pre class="line-numbers language-none"><code class="language-none">List&lt;String&gt; strList &#x3D; Arrays.asList(&quot;1,2,3&quot;, &quot;4,5,6&quot;);List&lt;String&gt; newStrList &#x3D; strList.stream().flatMap(item -&gt; &#123;  return Arrays.stream(item.split(&quot;,&quot;));&#125;).collect(Collectors.toList());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="12-搜索"><a href="#12-搜索" class="headerlink" title="12. 搜索"></a>12. 搜索</h6><pre class="line-numbers language-none"><code class="language-none">originData.stream().filter(data -&gt; Boolean.FALSE ? data.getName().equals(dto.getName()) :data.getName().contains(dto    .getName())).collect(Collectors.toList());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录学习设计模式-01-简单工厂和工厂方法</title>
      <link href="/2022/10/07/ji-lu-xue-xi-she-ji-mo-shi-01-jian-dan-gong-han-he-gong-han-fang-fa/"/>
      <url>/2022/10/07/ji-lu-xue-xi-she-ji-mo-shi-01-jian-dan-gong-han-he-gong-han-fang-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p><strong>先看下定义</strong><br><em>提供一个创建对象实例的功能，而无须关心其具体事项。被创建的类型可以是接口、抽象类，也可以是具体的类。</em></p><ol><li>为什么要有简单工厂？</li></ol><p>简单工厂将对象创建细节封装到工厂类中，通过提供的api接口和factory工厂创建对象。面向接口编程，更为抽象，符合面向对象设计。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Xcode11创建自定义UIWindow</title>
      <link href="/2021/10/21/ji-yu-xcode11-chuang-jian-zi-ding-yi-uiwindow/"/>
      <url>/2021/10/21/ji-yu-xcode11-chuang-jian-zi-ding-yi-uiwindow/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Xcode11创建自定义UIWindow"><a href="#基于Xcode11创建自定义UIWindow" class="headerlink" title="基于Xcode11创建自定义UIWindow"></a>基于Xcode11创建自定义UIWindow</h1><p>最近更新Xcode 11.4，在创建项目之后发现多了苹果分屏技术，新增了SceneDelegate这个文件，另外AppDelegate文件结构也发生了变化，给人一种似曾相识又不同的感觉，总的来说之前熟悉的Window不再由AppDelegate管理，而是交给了SceneDelegate。</p><p>如下图即可看出目录结构和info配置变化：<br><img src="/.io//16277872068447.png"></p><p>简要介绍Application Scene Manifest分屏配置：</p><pre class="line-numbers language-none"><code class="language-none">enable Multipe Windows --- 是否允许分屏Scene Configuratiton --- 屏幕配置项Application Session Role --- 程序屏幕配置规则（为每个Scene指定规则）Configuration Name --- 配置名称Delegate Class Name --- 代理类名称Storyboard Name --- Storyboard名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解读如下：</p><p>创建项目工程时，系统默认为我们创建了一个名为Default Configuratiton 的默认配置，代理类名称为SceneDelegate,入口名为Main的Storyboard，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">- (UISceneConfiguration *)application:(UIApplication *)application configurationForConnectingSceneSession:(UISceneSession *)connectingSceneSession options:(UISceneConnectionOptions *)options &#123;    &#x2F;&#x2F; Called when a new scene session is being created.    &#x2F;&#x2F; Use this method to select a configuration to create the new scene with.    return [[UISceneConfiguration alloc] initWithName:@&quot;Default Configuration&quot; sessionRole:connectingSceneSession.role];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回到主题，针对这种情况，如果创建我们熟悉的自定义Window呢？</p><p>一、针对iOS13系统及以上：保留SceneDelegate，需要修改SceneDelegate里面的代码即可；</p><pre class="line-numbers language-none"><code class="language-none">- (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions &#123;    &#x2F;&#x2F; Use this method to optionally configure and attach the UIWindow &#96;window&#96; to the provided UIWindowScene &#96;scene&#96;.    &#x2F;&#x2F; If using a storyboard, the &#96;window&#96; property will automatically be initialized and attached to the scene.    &#x2F;&#x2F; This delegate does not imply the connecting scene or session are new (see &#96;application:configurationForConnectingSceneSession&#96; instead).            if (@available(ios 13, *)) &#123;        if (scene) &#123;            self.window &#x3D; [[UIWindow alloc] initWithWindowScene:(UIWindowScene *)scene];            self.window.frame &#x3D; CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height);            UINavigationController *nav &#x3D; [[UINavigationController alloc] initWithRootViewController:[[ViewController alloc]init]];            self.window.rootViewController &#x3D; nav;            [self.window makeKeyAndVisible];        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果图：</p><p><img src="/.io//16277872853169.png" alt="-w308"></p><p>二、针对iOS13系统以下：</p><p>a. 删除info.plist文件中的Application Scene Manifest选项;</p><p>b. 删除SceneDelegate文件;</p><p>c. 删除AppDelegate里面的UISceneSession lifecycle方法;</p><p>d. AppDelegate头文件添加window属性;</p><p><code>@property (strong, nonatomic) UIWindow *window;</code><br>e. 修改AppDelegate启动方法：</p><pre class="line-numbers language-none"><code class="language-none">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;    &#x2F;&#x2F; Override point for customization after application launch.    self.window &#x3D; [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];    UIViewController *vc &#x3D; [[UIViewController alloc]init];    vc.view.backgroundColor &#x3D; [UIColor greenColor];    UINavigationController *nav &#x3D; [[UINavigationController alloc] initWithRootViewController:vc];    self.window.rootViewController &#x3D; nav;    [self.window makeKeyAndVisible];    return YES;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果图：</p><p><img src="/.io//16277873129770.png" alt="-w308"></p><p>至此，我们又回到了曾经熟悉的开发场景。</p>]]></content>
      
      
      <categories>
          
          <category> ios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> objective-c </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
